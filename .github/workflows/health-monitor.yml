name: Continuous Health Monitoring

on:
  schedule:
    # Run health checks every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch:
    inputs:
      force_recovery:
        description: 'Force recovery actions even if health checks pass'
        required: false
        type: boolean
        default: false
      skip_recovery:
        description: 'Skip recovery actions even if health checks fail'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  # Use the service hostname instead of localhost for health checks
  TAILPASTE_URL: http://tailpaste:8080

jobs:
  health-monitor:
    name: Continuous Health Monitoring
    runs-on:
      - tailpaste-runners
    
    # Required permissions for health monitoring
    permissions:
      contents: read
      actions: write      # Required to set repository variables
      id-token: write     # Required for OIDC and some API calls
    
    # Prevent concurrent health monitoring runs
    concurrency:
      group: health-monitoring
      cancel-in-progress: false
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Install GitHub CLI
        continue-on-error: true
        run: |
          chmod +x .github/scripts/install-gh-cli.sh
          .github/scripts/install-gh-cli.sh
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: 'requirements.txt'
      
      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-health-monitor-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-health-monitor-
            ${{ runner.os }}-pip-
      
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Connect to Tailscale
        uses: tailscale/github-action@v4
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_SECRET }}
          tags: tag:ci
          ping: docker.tailfa875.ts.net
      
      - name: Initialize health monitoring session
        run: |
          if [ -z "${{ secrets.GITHUB_TOKEN }}" ]; then
            echo "GITHUB_TOKEN is not set. Exiting."
            exit 1
          fi
          export GH_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          .github/scripts/health-check/init-monitoring-session.sh
      
      - name: Execute comprehensive health checks
        id: health_checks
        run: |
          if [ -z "${{ secrets.GITHUB_TOKEN }}" ]; then
            echo "GITHUB_TOKEN is not set. Exiting."
            exit 1
          fi
          export GH_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          .github/scripts/health-check/execute-health-checks.sh
      
      - name: Record health check results
        run: |
          if [ -z "${{ secrets.GITHUB_TOKEN }}" ]; then
            echo "GITHUB_TOKEN is not set. Exiting."
            exit 1
          fi
          export GH_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          .github/scripts/health-check/record-health-results.sh "${{ steps.health_checks.outputs.OVERALL_HEALTH }}" "${{ steps.health_checks.outputs.HEALTH_DETAILS }}"
      
      - name: Evaluate recovery conditions
        id: recovery_evaluation
        run: |
          echo "üîç Evaluating recovery conditions..."
          if [ -z "${{ secrets.GITHUB_TOKEN }}" ]; then
            echo "GITHUB_TOKEN is not set. Exiting."
            exit 1
          fi
          export GH_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          OVERALL_HEALTH="${{ steps.health_checks.outputs.OVERALL_HEALTH }}"
          FORCE_RECOVERY="${{ inputs.force_recovery }}"
          SKIP_RECOVERY="${{ inputs.skip_recovery }}"
          SHOULD_TRIGGER_RECOVERY=false
          RECOVERY_REASON=""
          # Check if recovery should be triggered
          if [ "$SKIP_RECOVERY" = "true" ]; then
            echo "‚è≠Ô∏è  Recovery skipped by manual input"
            RECOVERY_REASON="manually_skipped"
          elif [ "$FORCE_RECOVERY" = "true" ]; then
            echo "üîß Recovery forced by manual input"
            SHOULD_TRIGGER_RECOVERY=true
            RECOVERY_REASON="manually_forced"
          elif [ "$OVERALL_HEALTH" = "unhealthy" ]; then
            echo "üö® Health check failed - recovery needed"
            SHOULD_TRIGGER_RECOVERY=true
            RECOVERY_REASON="health_check_failed"
          elif [ "$OVERALL_HEALTH" = "degraded" ]; then
            echo "‚ö†Ô∏è  Service degraded - considering recovery"
            
            # Check if degraded state persists
            HEALTH_HISTORY=$(gh variable get HEALTH_CHECK_HISTORY --repo ${{ github.repository }} 2>/dev/null || echo "[]")
            
            export HEALTH_HISTORY
            CONSECUTIVE_DEGRADED=$(python3 scripts/health/count_consecutive_degraded.py)
            
            echo "Consecutive degraded/unhealthy checks: $CONSECUTIVE_DEGRADED"
            
            if [ "$CONSECUTIVE_DEGRADED" -ge 3 ]; then
              echo "üîß Persistent degradation detected - triggering recovery"
              SHOULD_TRIGGER_RECOVERY=true
              RECOVERY_REASON="persistent_degradation"
            else
              echo "‚ÑπÔ∏è  Degradation not persistent enough for recovery"
            fi
          else
            echo "‚úÖ Health check passed - no recovery needed"
          fi
          
          # Check circuit breaker status
          CIRCUIT_BREAKER_STATUS=$(gh variable get CIRCUIT_BREAKER_STATUS --repo ${{ github.repository }} 2>/dev/null || echo "closed")
          
          if [ "$SHOULD_TRIGGER_RECOVERY" = true ] && [ "$CIRCUIT_BREAKER_STATUS" = "open" ]; then
            echo "üö´ Circuit breaker is open - recovery blocked"
            SHOULD_TRIGGER_RECOVERY=false
            RECOVERY_REASON="circuit_breaker_open"
          fi
          
          echo "SHOULD_TRIGGER_RECOVERY=$SHOULD_TRIGGER_RECOVERY" >> $GITHUB_OUTPUT
          echo "RECOVERY_REASON=$RECOVERY_REASON" >> $GITHUB_OUTPUT
          
          # Record recovery evaluation
          gh variable set LAST_RECOVERY_EVALUATION --body "$(date -u +%Y-%m-%dT%H:%M:%SZ)" --repo ${{ github.repository }}
          gh variable set LAST_RECOVERY_DECISION --body "$SHOULD_TRIGGER_RECOVERY" --repo ${{ github.repository }}
          gh variable set LAST_RECOVERY_REASON --body "$RECOVERY_REASON" --repo ${{ github.repository }}
          
          if [ "$SHOULD_TRIGGER_RECOVERY" = true ]; then
            echo "üîß Recovery will be triggered: $RECOVERY_REASON"
          else
            echo "‚ÑπÔ∏è  No recovery action needed: $RECOVERY_REASON"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Trigger recovery workflow
        if: steps.recovery_evaluation.outputs.SHOULD_TRIGGER_RECOVERY == 'true'
        run: |
          echo "üöÄ Triggering recovery workflow..."
          if [ -z "${{ secrets.GITHUB_TOKEN }}" ]; then
            echo "GITHUB_TOKEN is not set. Exiting."
            exit 1
          fi
          export GH_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          RECOVERY_REASON="${{ steps.recovery_evaluation.outputs.RECOVERY_REASON }}"
          OVERALL_HEALTH="${{ steps.health_checks.outputs.OVERALL_HEALTH }}"
          # Clear any pending recovery triggers since we now have the workflow
          gh variable delete PENDING_RECOVERY_TRIGGER --repo ${{ github.repository }} 2>/dev/null || true
          gh variable delete PENDING_RECOVERY_REASON --repo ${{ github.repository }} 2>/dev/null || true
          gh variable delete PENDING_RECOVERY_HEALTH_STATUS --repo ${{ github.repository }} 2>/dev/null || true
          gh variable delete PENDING_RECOVERY_TIMESTAMP --repo ${{ github.repository }} 2>/dev/null || true
          # Trigger recovery workflow
          gh workflow run recovery.yml \
            --repo ${{ github.repository }} \
            --field health_status="$OVERALL_HEALTH" \
            --field recovery_reason="$RECOVERY_REASON" \
            --field monitoring_session_id="$MONITORING_SESSION_ID" \
            --field triggered_by="health_monitor"
          if [ $? -eq 0 ]; then
            echo "‚úÖ Recovery workflow triggered successfully"
            # Record recovery trigger
            gh variable set LAST_RECOVERY_TRIGGER --body "$(date -u +%Y-%m-%dT%H:%M:%SZ)" --repo ${{ github.repository }}
            gh variable set LAST_RECOVERY_TRIGGER_REASON --body "$RECOVERY_REASON" --repo ${{ github.repository }}
          else
            echo "‚ùå Failed to trigger recovery workflow"
            # Record failure
            gh variable set LAST_RECOVERY_TRIGGER_FAILURE --body "$(date -u +%Y-%m-%dT%H:%M:%SZ)" --repo ${{ github.repository }}
          fi
      
      - name: Generate health monitoring summary
        if: always()
        run: |
          echo "üìã Generating health monitoring summary..."
          if [ -z "${{ secrets.GITHUB_TOKEN }}" ]; then
            echo "GITHUB_TOKEN is not set. Exiting."
            exit 1
          fi
          export GH_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          OVERALL_HEALTH="${{ steps.health_checks.outputs.OVERALL_HEALTH }}"
          HEALTH_DETAILS="${{ steps.health_checks.outputs.HEALTH_DETAILS }}"
          SHOULD_TRIGGER_RECOVERY="${{ steps.recovery_evaluation.outputs.SHOULD_TRIGGER_RECOVERY }}"
          RECOVERY_REASON="${{ steps.recovery_evaluation.outputs.RECOVERY_REASON }}"
          # Create comprehensive summary
          echo "## üè• Continuous Health Monitoring Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Monitoring Session" >> $GITHUB_STEP_SUMMARY
          echo "- **Session ID**: \`$MONITORING_SESSION_ID\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed Artifact**: \`${DEPLOYED_DIGEST:-'none'}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Health Check Results" >> $GITHUB_STEP_SUMMARY
          # Overall status with emoji
          case "$OVERALL_HEALTH" in
            "healthy")
              echo "- **Overall Status**: ‚úÖ **HEALTHY**" >> $GITHUB_STEP_SUMMARY
              ;;
            "degraded")
              echo "- **Overall Status**: ‚ö†Ô∏è  **DEGRADED**" >> $GITHUB_STEP_SUMMARY
              ;;
            "unhealthy")
              echo "- **Overall Status**: ‚ùå **UNHEALTHY**" >> $GITHUB_STEP_SUMMARY
              ;;
            *)
              echo "- **Overall Status**: ‚ùì **UNKNOWN**" >> $GITHUB_STEP_SUMMARY
              ;;
          esac
          echo "- **Details**: $HEALTH_DETAILS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          # Individual check results
          echo "### Individual Check Results" >> $GITHUB_STEP_SUMMARY
          SERVICE_AVAILABLE="${{ steps.health_checks.outputs.SERVICE_AVAILABLE }}"
          FUNCTIONALITY_OK="${{ steps.health_checks.outputs.FUNCTIONALITY_OK }}"
          CONTAINER_HEALTHY="${{ steps.health_checks.outputs.CONTAINER_HEALTHY }}"
          echo "- **Service Availability**: $([ "$SERVICE_AVAILABLE" = "true" ] && echo "‚úÖ Available" || echo "‚ùå Unavailable")" >> $GITHUB_STEP_SUMMARY
          echo "- **Basic Functionality**: $([ "$FUNCTIONALITY_OK" = "true" ] && echo "‚úÖ Working" || echo "‚ùå Failed")" >> $GITHUB_STEP_SUMMARY
          echo "- **Container Health**: $([ "$CONTAINER_HEALTHY" = "true" ] && echo "‚úÖ Healthy" || echo "‚ùå Unhealthy")" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          # Recovery evaluation
          echo "### Recovery Evaluation" >> $GITHUB_STEP_SUMMARY
          echo "- **Recovery Needed**: $([ "$SHOULD_TRIGGER_RECOVERY" = "true" ] && echo "‚úÖ Yes" || echo "‚ùå No")" >> $GITHUB_STEP_SUMMARY
          echo "- **Reason**: $RECOVERY_REASON" >> $GITHUB_STEP_SUMMARY
          if [ "$SHOULD_TRIGGER_RECOVERY" = "true" ]; then
            echo "- **Action**: Recovery workflow triggered" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*üîÑ Next health check scheduled in 5 minutes*" >> $GITHUB_STEP_SUMMARY
          echo "‚úÖ Health monitoring summary generated"
      
      - name: Cleanup monitoring session
        if: always()
        run: |
          echo "üßπ Cleaning up monitoring session..."
          if [ -z "${{ secrets.GITHUB_TOKEN }}" ]; then
            echo "GITHUB_TOKEN is not set. Exiting."
            exit 1
          fi
          export GH_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          # Check if gh CLI is available
          if ! command -v gh &> /dev/null; then
            echo "‚ö†Ô∏è  GitHub CLI not available - skipping variable cleanup"
            echo "   (Variables will be cleaned up on next successful run)"
          else
            # Clear session variables
            gh variable delete HEALTH_MONITORING_SESSION --repo ${{ github.repository }} 2>/dev/null || true
            # Update last completed monitoring session
            gh variable set LAST_COMPLETED_HEALTH_CHECK --body "$(date -u +%Y-%m-%dT%H:%M:%SZ)" --repo ${{ github.repository }} || echo "‚ö†Ô∏è  Failed to update LAST_COMPLETED_HEALTH_CHECK"
            gh variable set LAST_COMPLETED_SESSION_ID --body "$MONITORING_SESSION_ID" --repo ${{ github.repository }} || echo "‚ö†Ô∏è  Failed to update LAST_COMPLETED_SESSION_ID"
            echo "‚úÖ Monitoring session cleanup completed"
          fi